#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
var debug = require('debug')('express:server')
var http = require('http')
var WebSocket = require('ws')
var crypto = require('crypto')

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
 * Create HTTP server.
 */

var server = http.createServer(app)

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port)
server.on('error', onError)
server.on('listening', onListening)

/**
 * WebSocket Server for Beads Distribution System
 */

// 創建 WebSocket 伺服器
const wss = new WebSocket.Server({ server })

// 儲存房間資訊
const beadsRooms = new Map()

// 生成房間序號
function generateRoomId() {
	return crypto.randomBytes(4).toString('hex').toUpperCase()
}

wss.on('connection', ws => {
	console.log('New WebSocket client connected for beads system')

	ws.on('message', data => {
		try {
			const message = JSON.parse(data)
			console.log('Received beads message:', message)

			switch (message.type) {
				case 'create_beads_room':
					const roomId = generateRoomId()
					const playerName = message.playerName || '匿名用戶'

					beadsRooms.set(roomId, {
						clients: new Set([ws]),
						members: [
							{
								id: Date.now(),
								name: playerName,
								isCaptain: true,
							},
						],
						gameState: {
							team: [],
							rounds: [],
							sales: [],
							salesConfig: [],
							randomBeads: 0,
							lastIndex: 0,
						},
						captain: ws, // 創建者為隊長
					})
					ws.roomId = roomId
					ws.isCaptain = true
					ws.playerName = playerName
					ws.id = Date.now()

					const room = beadsRooms.get(roomId)
					ws.send(
						JSON.stringify({
							type: 'beads_room_created',
							roomId: roomId,
							isCaptain: true,
							roomMembers: room.members,
						}),
					)
					break

				case 'join_beads_room':
					const { roomId: joinRoomId, playerName: joinPlayerName } = message
					if (beadsRooms.has(joinRoomId)) {
						const room = beadsRooms.get(joinRoomId)
						const newPlayerName = joinPlayerName || '匿名用戶'

						// 檢查名稱是否重複
						const nameExists = room.members.some(
							member => member.name === newPlayerName,
						)
						if (nameExists) {
							ws.send(
								JSON.stringify({
									type: 'error',
									message: '此名稱已被使用，請選擇其他名稱',
								}),
							)
							break
						}

						room.clients.add(ws)
						ws.roomId = joinRoomId
						ws.isCaptain = false
						ws.playerName = newPlayerName
						ws.id = Date.now()

						// 添加到房間成員列表
						room.members.push({
							id: ws.id,
							name: newPlayerName,
							isCaptain: false,
						})

						// 發送當前遊戲狀態給新加入的用戶
						ws.send(
							JSON.stringify({
								type: 'beads_room_joined',
								roomId: joinRoomId,
								gameState: room.gameState,
								isCaptain: false,
								roomMembers: room.members,
							}),
						)

						// 通知房間內其他用戶有新人加入，並更新成員列表
						room.clients.forEach(client => {
							if (client !== ws && client.readyState === WebSocket.OPEN) {
								client.send(
									JSON.stringify({
										type: 'user_joined_beads',
										playerName: newPlayerName,
									}),
								)
								client.send(
									JSON.stringify({
										type: 'room_members_updated',
										roomMembers: room.members,
									}),
								)
							}
						})
					} else {
						ws.send(
							JSON.stringify({
								type: 'error',
								message: '房間不存在',
							}),
						)
					}
					break

				case 'update_game_state':
					if (ws.roomId && beadsRooms.has(ws.roomId) && ws.isCaptain) {
						const room = beadsRooms.get(ws.roomId)
						room.gameState = message.gameState

						// 廣播遊戲狀態更新給房間內所有用戶
						room.clients.forEach(client => {
							if (client.readyState === WebSocket.OPEN) {
								client.send(
									JSON.stringify({
										type: 'game_state_updated',
										gameState: room.gameState,
									}),
								)
							}
						})
					}
					break
			}
		} catch (error) {
			console.error('Error parsing WebSocket message:', error)
		}
	})

	// 當連接關閉時
	ws.on('close', () => {
		console.log('WebSocket client disconnected from beads system')

		// 從房間中移除用戶
		if (ws.roomId && beadsRooms.has(ws.roomId)) {
			const room = beadsRooms.get(ws.roomId)
			room.clients.delete(ws)

			// 從成員列表中移除
			room.members = room.members.filter(member => member.id !== ws.id)

			// 如果房間沒有用戶了，刪除房間
			if (room.clients.size === 0) {
				beadsRooms.delete(ws.roomId)
				console.log(`Beads room ${ws.roomId} deleted`)
			} else {
				// 如果隊長離開，指定新隊長
				if (ws.isCaptain && room.clients.size > 0) {
					const newCaptain = room.clients.values().next().value
					newCaptain.isCaptain = true
					room.captain = newCaptain

					// 更新成員列表中的隊長狀態
					const newCaptainMember = room.members.find(
						member => member.id === newCaptain.id,
					)
					if (newCaptainMember) {
						newCaptainMember.isCaptain = true
					}

					// 通知新隊長
					newCaptain.send(
						JSON.stringify({
							type: 'promoted_to_captain',
							message: '你已成為新隊長',
						}),
					)
				}

				// 通知其他用戶有人離開，並更新成員列表
				room.clients.forEach(client => {
					if (client.readyState === WebSocket.OPEN) {
						client.send(
							JSON.stringify({
								type: 'user_left_beads',
								playerName: ws.playerName || '匿名用戶',
							}),
						)
						client.send(
							JSON.stringify({
								type: 'room_members_updated',
								roomMembers: room.members,
							}),
						)
					}
				})
			}
		}
	})
})

console.log('WebSocket server for beads system integrated with HTTP server on port', port)

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10)

	if (isNaN(port)) {
		// named pipe
		return val
	}

	if (port >= 0) {
		// port number
		return port
	}

	return false
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error
	}

	var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges')
			process.exit(1)
			break
		case 'EADDRINUSE':
			console.error(bind + ' is already in use')
			process.exit(1)
			break
		default:
			throw error
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = server.address()
	var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port
	debug('Listening on ' + bind)
}
